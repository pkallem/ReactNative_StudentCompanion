{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { EventEmitter, Platform } from '@unimodules/core';\n\nvar DeviceSensor = function () {\n  function DeviceSensor(nativeSensorModule, nativeEventName) {\n    _classCallCheck(this, DeviceSensor);\n\n    this._nativeModule = nativeSensorModule;\n    this._nativeEmitter = new EventEmitter(nativeSensorModule);\n    this._nativeEventName = nativeEventName;\n    this._listenerCount = 0;\n  }\n\n  _createClass(DeviceSensor, [{\n    key: \"addListener\",\n    value: function addListener(listener) {\n      var _this = this;\n\n      var subscription = this._nativeEmitter.addListener(this._nativeEventName, listener);\n\n      subscription.remove = function () {\n        return _this.removeSubscription(subscription);\n      };\n\n      this._listenerCount++;\n      return subscription;\n    }\n  }, {\n    key: \"hasListeners\",\n    value: function hasListeners() {\n      return this._listenerCount > 0;\n    }\n  }, {\n    key: \"getListenerCount\",\n    value: function getListenerCount() {\n      return this._listenerCount;\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this._listenerCount = 0;\n\n      this._nativeEmitter.removeAllListeners(this._nativeEventName);\n    }\n  }, {\n    key: \"removeSubscription\",\n    value: function removeSubscription(subscription) {\n      this._listenerCount--;\n\n      this._nativeEmitter.removeSubscription(subscription);\n    }\n  }, {\n    key: \"setUpdateInterval\",\n    value: function setUpdateInterval(intervalMs) {\n      if (!this._nativeModule.setUpdateInterval) {\n        console.warn(\"expo-sensors: setUpdateInterval() is not supported on \" + Platform.OS);\n      } else {\n        this._nativeModule.setUpdateInterval(intervalMs);\n      }\n    }\n  }, {\n    key: \"isAvailableAsync\",\n    value: function isAvailableAsync() {\n      return _regeneratorRuntime.async(function isAvailableAsync$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (this._nativeModule.isAvailableAsync) {\n                _context.next = 4;\n                break;\n              }\n\n              return _context.abrupt(\"return\", false);\n\n            case 4:\n              _context.next = 6;\n              return _regeneratorRuntime.awrap(this._nativeModule.isAvailableAsync());\n\n            case 6:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n\n  return DeviceSensor;\n}();\n\nexport { DeviceSensor as default };","map":{"version":3,"sources":["../src/DeviceSensor.ts"],"names":[],"mappings":";;;AAAA,SAAS,YAAT,EAAqC,QAArC,QAAqD,kBAArD;;IAUqB,Y;AAMnB,wBAAY,kBAAZ,EAAoD,eAApD,EAA2E;AAAA;;AACzE,SAAK,aAAL,GAAqB,kBAArB;AACA,SAAK,cAAL,GAAsB,IAAI,YAAJ,CAAiB,kBAAjB,CAAtB;AACA,SAAK,gBAAL,GAAwB,eAAxB;AACA,SAAK,cAAL,GAAsB,CAAtB;AACD;;;;WAED,qBAAY,QAAZ,EAAiC;AAAA;;AAC/B,UAAM,YAAY,GAAG,KAAK,cAAL,CAAoB,WAApB,CAAgC,KAAK,gBAArC,EAAuD,QAAvD,CAArB;;AACA,MAAA,YAAY,CAAC,MAAb,GAAsB;AAAA,eAAM,KAAI,CAAC,kBAAL,CAAwB,YAAxB,CAAN;AAAA,OAAtB;;AACA,WAAK,cAAL;AACA,aAAO,YAAP;AACD;;;WAED,wBAAY;AACV,aAAO,KAAK,cAAL,GAAsB,CAA7B;AACD;;;WAED,4BAAgB;AACd,aAAO,KAAK,cAAZ;AACD;;;WAED,8BAAkB;AAChB,WAAK,cAAL,GAAsB,CAAtB;;AACA,WAAK,cAAL,CAAoB,kBAApB,CAAuC,KAAK,gBAA5C;AACD;;;WAED,4BAAmB,YAAnB,EAA6C;AAC3C,WAAK,cAAL;;AACA,WAAK,cAAL,CAAoB,kBAApB,CAAuC,YAAvC;AACD;;;WAED,2BAAkB,UAAlB,EAAoC;AAClC,UAAI,CAAC,KAAK,aAAL,CAAmB,iBAAxB,EAA2C;AACzC,QAAA,OAAO,CAAC,IAAR,4DAAsE,QAAQ,CAAC,EAA/E;AACD,OAFD,MAEO;AACL,aAAK,aAAL,CAAmB,iBAAnB,CAAqC,UAArC;AACD;AACF;;;WACD;AAAA;AAAA;AAAA;AAAA;AAAA,kBACO,KAAK,aAAL,CAAmB,gBAD1B;AAAA;AAAA;AAAA;;AAAA,+CAEW,KAFX;;AAAA;AAAA;AAAA,+CAIiB,KAAK,aAAL,CAAmB,gBAAnB,EAJjB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;SA7CmB,Y","sourcesContent":["import { EventEmitter, Subscription, Platform } from '@unimodules/core';\n\ntype Listener<E> = (event: E) => void;\n\ntype NativeSensorModule = any;\n\n/**\n * A base class for subscribable sensors. The events emitted by this class are measurements\n * specified by the parameter type `M`.\n */\nexport default class DeviceSensor<M> {\n  _nativeModule: NativeSensorModule;\n  _nativeEmitter: EventEmitter;\n  _nativeEventName: string;\n  _listenerCount: number;\n\n  constructor(nativeSensorModule: NativeSensorModule, nativeEventName: string) {\n    this._nativeModule = nativeSensorModule;\n    this._nativeEmitter = new EventEmitter(nativeSensorModule);\n    this._nativeEventName = nativeEventName;\n    this._listenerCount = 0;\n  }\n\n  addListener(listener: Listener<M>): Subscription {\n    const subscription = this._nativeEmitter.addListener(this._nativeEventName, listener);\n    subscription.remove = () => this.removeSubscription(subscription);\n    this._listenerCount++;\n    return subscription;\n  }\n\n  hasListeners(): boolean {\n    return this._listenerCount > 0;\n  }\n\n  getListenerCount(): number {\n    return this._listenerCount;\n  }\n\n  removeAllListeners(): void {\n    this._listenerCount = 0;\n    this._nativeEmitter.removeAllListeners(this._nativeEventName);\n  }\n\n  removeSubscription(subscription: Subscription): void {\n    this._listenerCount--;\n    this._nativeEmitter.removeSubscription(subscription);\n  }\n\n  setUpdateInterval(intervalMs: number): void {\n    if (!this._nativeModule.setUpdateInterval) {\n      console.warn(`expo-sensors: setUpdateInterval() is not supported on ${Platform.OS}`);\n    } else {\n      this._nativeModule.setUpdateInterval(intervalMs);\n    }\n  }\n  async isAvailableAsync(): Promise<boolean> {\n    if (!this._nativeModule.isAvailableAsync) {\n      return false;\n    } else {\n      return await this._nativeModule.isAvailableAsync();\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}